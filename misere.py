# -*- coding: utf-8 -*-
"""Misere

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1juG6vXKx4Cpf0FsDXcMY4NucAlFXUqsG
"""

import random
from collections import Counter
import operator
import pandas as pd
import numpy as np

"""# Classes"""

class Card:
  def __init__(self,suit,pip):
    self.numericalValue=0
    self.suit=suit
    self.pip=pip
    if pip=="J":
      self.numericalValue=11
    if pip=="Q":
      self.numericalValue=12
    if pip=="K":
      self.numericalValue=13
    if pip=="A":
      self.numericalValue=14
    elif self.numericalValue==0:
      self.numericalValue=int(pip)

    self.sortCase=[suit,pip]

  def __str__(self):
    return f"{self.pip}{self.suit}"

  def getCard(self):
    return f"{self.pip}{self.suit}"

  def __hash__(self):
    return hash(self.pip+self.suit)

  def __eq__(self,other):
    return self.numericalValue==other.numericalValue and self.suit==other.suit

  def __gt__(self,other):
    if self.suit==other.suit:
      return self.numericalValue>other.numericalValue
    else:
      return self.suit>other.suit

  def __lt__(self,other):
    return not self.__gt__(other) and not self.__eq__(other)

  def __repr__(self):
    return self.__str__()

class Player:
  def __init__(self,name,hand):
    if len(hand)==0:
      print("Error Initialising Player")
    self.hand=list(sorted(hand,key=lambda x: (x.suit,x.numericalValue)))
    self.dealt=tuple(self.hand)
    self.played=[]
    self.name=name
    self.suitReset()

  def suitSearch(self,suit):
    if suit=="♦":
      return self.diamond
    if suit=="♣":
      return self.club
    if suit=="♥":
      return self.heart
    if suit=="♠":
      return self.spade

  def reset(self,newplay=None):
    self.hand=[item for item in self.dealt]
    self.played=[]
    self.suitReset()
    if len(newplay)>1:
      for card in newplay:
        if card in self.hand:
          self.play(card)
    if len(self.hand)==0:
      print("Error resetting player")

  def suitReset(self):
    self.club=[]
    self.diamond=[]
    self.heart=[]
    self.spade=[]
    for card in self.hand:
      if card.suit=="♦":
        self.diamond.append(card)
      elif card.suit=="♣":
        self.club.append(card)
      elif card.suit=="♥":
        self.heart.append(card)
      elif card.suit=="♠":
        self.spade.append(card)


  def play(self,card):
    self.played.append(card)
    self.hand.remove(card)
    if card in self.diamond:
      self.diamond.remove(card)
    elif card in self.club:
      self.club.remove(card)
    elif card in self.heart:
      self.heart.remove(card)
    elif card in self.spade:
      self.spade.remove(card)

  def __str__(self):
    playables=self.name+": "
    for card in self.hand:
      playables+=" "+card.getCard()
    return playables

  def removeCard(self,card):
    if card in self.hand:
      self.hand.remove(card)
    else:
      print("Card not in hand")

  def suitHand(self,suit):
    if card.suit=="♦":
      return self.diamond
    elif card.suit=="♣":
      return self.club
    elif card.suit=="♥":
      return self.heart
    elif card.suit=="♠":
      return self.spade

class Node:
  def __init__(self,children,playOrder,played,depth,bettor=0):
    self.children=[]
    self.playOrder=playOrder
    self.played=played
    self.depth=depth
    self.trump=None
    self.bettor=bettor

  def __str__(self):
    return self.playOrder

  def addChild(self,child):
    self.children.append(child)

  def winningLines(self):
      pass

"""# Tree Builder

"""

def compareSuits(suit1,suit2,hand):
  suit1Hand=[]
  suit2Hand=[]
  if suit1==suit2:
    return suit1
  for card in hand:
    if card.suit==suit1:
      suit1Hand.append(card)
    elif card.suit==suit2:
      suit2Hand.append(card)
  if len(suit1Hand)!=len(suit2Hand):
    print("max suit is ",suit1, " and compared to ",suit2)
    print("Error, mismatched suit length in compareSuits")
    return suit1
  elif len(suit1Hand)==1:
    if suit1Hand[0]>suit2Hand[0]:
      return suit1
    return suit2
  elif len(suit1Hand)==2:
    suit1Hand.sort()
    suit2Hand.sort()
    if suit1Hand[0]>suit2Hand[0]:
      return suit1
    elif suit1Hand[0]==suit2Hand[0]:
      if suit1Hand[1]>suit2Hand[1]:
        return suit1
  return suit2

def fullGameScorer(playorder):
  players=int(len(playorder)/5)
  scores=[0]*players
  lastWinner=0
  trump=playorder[0].suit
  leadCard=playorder[::players]
  for i in range(0,5):
    trumpPlayed=False
    round=playorder[(i*players):((i+1)*players)]
    winningCard=round[0]

    if winningCard.suit==trump:
        trumpPlayed=True
    for card in round:
      if card.suit==trump and not trumpPlayed:
        winningCard=card
        trumpPlayed=True
      if card.suit==trump and card>winningCard:
        winningCard=card
      elif card.suit!=trump and card.suit==leadCard[i].suit and card>winningCard:
        winningCard=card
    ##print(round.index(winningCard))
    scores[(round.index(winningCard)+lastWinner)%4]+=1
    lastWinner+=round.index(winningCard)
    lastWinner=lastWinner%4
    #print(lastWinner)
  return scores

def winnerCalc(playedCard,trump,suitFollowing,position=False):
  trumpPlayed= trump==suitFollowing
  winningCard=playedCard[0]
  for card in playedCard:
    if card.suit==trump and card>winningCard and trumpPlayed:
      winningCard=card
      trumpPlayed=True
    elif card.suit==trump and not trumpPlayed:
      winningCard=card
      trumpPlayed=True
    elif card.suit==suitFollowing and card>winningCard and not trumpPlayed:
      winningCard=card
  if not position:
    return winningCard
  else:
    return np.where(playedCard==winningCard)[0][0]

def roundWinner(playedCard,trump):
  winningCard=playedCard[0]
  suitFollowing=winningCard.suit
  winningIndex=0
  trumpPlayeed=playedCard[0].suit==trump
  for i in range(1,4):
    card=playedCard[i]
    if trumpPlayed:
      if card.suit==trump and card>winningCard:
        winningCard=card
        winningIndex=i
    elif card.suit==trump:
      winningCard=card
      winningIndex=i
      trumpPlayed=True
    elif card.suit==suitFollowing and card>winningCard:
      winningCard=card
      winningIndex=i
  return winningIndex

def stateDecoder(playOrder):
  trump=playOrder[0].suit
  roundCount=len(playOrder)/4
  lead=0
  for i in range(int(roundCount)):
    playRound=playOrder[(i*4):((i+1)*4)]
    lead=roundWinner(playRound,trump)
  return lead

def suitsDistribution(selection):
  suitInHand=[]
  for card in selection:
    suitInHand.append(card.suit)
  suitDistribution=Counter(suitInHand)
  return suitDistribution

deck=[]
suit=["♦","♣","♥","♠"]
pips=["2","3","4","5","6","7","8","9","10","J","Q","K","A"]
for i in range(4):
  for j in range(13):
    #card=[pips[j],suit[i],pips[j]+suit[i]]
    deck.append(Card(suit[i],pips[j]))
for card in deck:
  print(card,end=" ")
print("\n")
random.shuffle(deck)
for card in deck:
  print(card,end=" ")

treePlayer1=Player("Bettor",deck[0:5])
treePlayer2=Player("Defence 1",deck[5:10])
treePlayer3=Player("Defence 2",deck[10:15])
treePlayer4=Player("Defence 3",deck[15:20])
treePlayerOrder=[treePlayer1,treePlayer2,treePlayer3,treePlayer4]
for player in treePlayerOrder:
  for card in player.hand:
    print(card,end=" ")
  print("\n")

"""# Node Builders"""

def nodeAdder(parent):
  children = nodeMaker(parent)
  if children is False:
    return
  parent.children.extend(children)
  if children:
    for child in children:
      nodeAdder(child)

import itertools

# Refactor winnerCalc to find the index of the winning card in the list
# Keeping memoization as it might help at deeper levels
winnerCalcCache = {}

def getWinnerCalcKey(playedCard, trump, suitFollowing):
  """Generates a unique, hashable key for winnerCalc cache."""
  return (tuple(playedCard), trump, suitFollowing)

def winnerCalc(playedCard, trump, suitFollowing, position=False):
  """
  Calculates the winner of a trick with memoization.
  Returns the winning Card object or the index of the winning player.
  """
  cacheKey = getWinnerCalcKey(playedCard, trump, suitFollowing)

  if cacheKey in winnerCalcCache:
    cachedWinnerIndex = winnerCalcCache[cacheKey]
    if position:
      return cachedWinnerIndex
    else:
      return playedCard[cachedWinnerIndex]

  trumpPlayed = False
  winningCard = playedCard[0]
  winningIndex = 0

  if winningCard.suit == trump:
    trumpPlayed = True

  for i in range(1, len(playedCard)):
    card = playedCard[i]
    if trumpPlayed:
      if card.suit == trump and card > winningCard:
        winningCard = card
        winningIndex = i
    elif card.suit == trump:
      winningCard = card
      winningIndex = i
      trumpPlayed = True
    elif card.suit == suitFollowing and card > winningCard and not trumpPlayed:
      winningCard = card
      winningIndex = i

  winnerCalcCache[cacheKey] = winningIndex

  if position:
    return winningIndex
  else:
    return playedCard[winningIndex]

def betterCard(challenger, king, trump):
  if challenger.suit == king.suit:
    return challenger > king
  elif challenger.suit == trump:
    return True
  return False

def combo2Nodes(allCombinations, winners, depth, playOrder, previouslyPlayed):
  childrenNodes = []
  for i in range(0,len(allCombinations)):
    newPlayed=[]
    newPlayed+=previouslyPlayed
    playedCards = allCombinations[i]
    winnerIndex = winners[i]
    # Rotate the playOrder based on the winnerIndex
    newPlayOrder = playOrder[winnerIndex:] + playOrder[:winnerIndex]
    newPlayed+=playedCards
    print(newPlayed)
    childrenNodes.append(Node([], newPlayOrder, newPlayed, depth + 1, ((4-winnerIndex)%4)))
  return childrenNodes

"""# nodeMaker"""

import itertools

nodeMakerCache = {}

def nodeMaker(parentNode):

  #if parentNode.depth==1:
  #  return
  if parentNode.depth==5:
    return []

  currentBettorPosition = parentNode.bettor
  allPlayedCards = []
  for card in parentNode.played:
    allPlayedCards.append(card)
  playedKey = tuple(sorted(allPlayedCards, key=lambda card: (card.suit, card.numericalValue)))
  cacheKey = (currentBettorPosition, playedKey)

  if cacheKey in nodeMakerCache:
    return nodeMakerCache[cacheKey]

  for player in parentNode.playOrder:
    player.reset(parentNode.played)

  if parentNode.depth>0:
    currentTrump=parentNode.trump
  if parentNode.depth == 4:
    finalPlay=[]
    for player in parentNode.playOrder:
      finalPlay.append(player.hand[0])
    winner=winnerCalc(finalPlay,currentTrump,finalPlay[0].suit,True)
    # print(finalPlay)
    # return combo2Nodes(finalPlay,winners,parentNode.depth,parentNode.playOrder,parentNode.played)
    finalOrder=parentNode.played[:]+finalPlay
    return [Node([], parentNode.playOrder, finalOrder, 5, ((4-winner)%4))]

  if currentBettorPosition==0:
    winState = 1
  else:
    winState=0

  leadingPlayer = parentNode.playOrder[-4]
  plays = leadingPlayer.hand
  allCombinations = []
  suits = ["♦", "♣", "♥", "♠"]
  currentTrump = parentNode.trump

  for leadCard in plays:
    if parentNode.depth == 0:
      currentTrump = leadCard.suit
    validResponses = [[], [], []]
    for i in range(0, 3):
      responder = parentNode.playOrder[i + 1]
      if len(responder.suitSearch(leadCard.suit)) > 0:
        validResponses[i] = responder.suitSearch(leadCard.suit)
      elif len(responder.suitSearch(leadCard.suit)) == 0:
        longestSuits = suits[:]
        longestSuits.remove(leadCard.suit)
        longestSuitLength = 1
        tempLongestSuits = []
        for suit in longestSuits:
          suitHand = responder.suitSearch(suit)
          if len(suitHand) > longestSuitLength:
            longestSuitLength = len(suitHand)
            tempLongestSuits = [suit]
          elif len(suitHand) == longestSuitLength and len(suitHand) > 0:
            tempLongestSuits.append(suit)
        if len(responder.suitSearch(leadCard.suit)) == 0:
          for suit in tempLongestSuits:
            suitResponse=responder.suitSearch(suit)
            for givenSuitCard in suitResponse:
              validResponses[i].append(givenSuitCard)
        else:
          for suit in tempLongestSuits:
            suitResponse=responder.suitSearch(suit)
            for givenSuitCard in suitResponse:
              validResponses[i].append(givenSuitCard)
      winningResponses=[[],[],[]]
      losingResponses=[[],[],[]]
      for i in range(0,3):
        for play in validResponses[i]:
          canBeat=betterCard(play,leadCard,currentTrump)
          if canBeat:
            winningResponses[i].append(play)
          if not canBeat:
            losingResponses[i].append(play)
        if len(losingResponses[i])==0:
          losingResponses[i]=winningResponses[i]
        lowestCards = {}
        for card in losingResponses[i]:
          if card.suit not in lowestCards or card.numericalValue < lowestCards[card.suit].numericalValue:
            lowestCards[card.suit] = card
        losingResponses[i]=lowestCards.values()
    trueResponses=[[],[],[]]

    for i in range(0,3):
      bettor= ( (i+1)==parentNode.bettor )
      if winState==1:
        if len(winningResponses[0])==0:
          trueResponses[i]=losingResponses[i]
        else:
          trueResponses[i]=winningResponses[i]
          winState=-1
      elif winState==0:
        if len(winningResponses[i])==0:
          trueResponses[i]=losingResponses[i]
          if bettor:
            winState=-1
        else:
          trueResponses[i]=winningResponses[i]
          if bettor:
            winState=1
      elif winState==-1:
        trueResponses[i]=losingResponses[i]

    for resp1 in trueResponses[0]:
      for resp2 in trueResponses[1]:
        for resp3 in trueResponses[2]:
          print(leadCard,resp1,resp2,resp3)
          allCombinations.append([leadCard,resp1,resp2,resp3])

  winners=[]
  for trick in allCombinations:
    winners.append(winnerCalc(trick,currentTrump,leadCard.suit,True))


  allChildren=combo2Nodes(allCombinations,winners, parentNode.depth, parentNode.playOrder, parentNode.played)
  nodeMakerCache[cacheKey] = allChildren

  return allChildren

"""# The Misery"""

import itertools

nodeMakerMisereCache = {}
#nodeMakerMisere is different from nodeMaker, as it tries to evaluate the winning bet of Misere
#Misere is a bet of 0 tricks, however, the bettor must still lead the 1st trick, thus determining the trump
#Tree generation can have less stringent rules, as if the bettor wins a single trick,
# the branch doesn't need to be explored further. The opposition must try and dump trumps where possible
# and take opportunities to either void other suits to avoid following, or throw high cards in long suits
# so as to be synced with their allies and catch the bettor off target.
#All the same rules about following where possible, trumps winning even if not led apply
def nodeMakerMisere(parentNode):

  # if parentNode.depth==1:
  #   return
  if parentNode.depth==5:
    return []

  currentBettorPosition = parentNode.bettor
  allPlayedCards = []
  for card in parentNode.played:
    allPlayedCards.append(card)
  playedKey = tuple(sorted(allPlayedCards, key=lambda card: (card.suit, card.numericalValue)))
  cacheKey = (currentBettorPosition, playedKey)

  if cacheKey in nodeMakerMisereCache:
    return nodeMakerMisereCache[cacheKey]

  for player in parentNode.playOrder:
    player.reset(parentNode.played)

  if parentNode.depth>0:
    currentTrump=parentNode.trump
    if parentNode.playOrder[0]==parentNode.bettor:
      return []
  if parentNode.depth == 4:
    finalPlay=[]
    for player in parentNode.playOrder:
      finalPlay.append(player.hand[0])
    winner=winnerCalc(finalPlay,currentTrump,finalPlay[0].suit,True)
    # print(finalPlay)
    # return combo2Nodes(finalPlay,winners,parentNode.depth,parentNode.playOrder,parentNode.played)
    finalOrder=parentNode.played[:]+finalPlay
    return [Node([], parentNode.playOrder, finalOrder, 5, ((4-winner)%4))]

  if currentBettorPosition==0:
    winState = 1
  else:
    winState=0

  leadingPlayer = parentNode.playOrder[-4]
  plays = leadingPlayer.hand
  allCombinations = []
  suits = ["♦", "♣", "♥", "♠"]
  currentTrump = parentNode.trump

  for leadCard in plays:
    if parentNode.depth == 0:
      currentTrump = leadCard.suit
    validResponses = [[], [], []]
    for i in range(0, 3):
      responder = parentNode.playOrder[i + 1]
      if len(responder.suitSearch(leadCard.suit)) > 0:
        validResponses[i] = responder.suitSearch(leadCard.suit)
      elif len(responder.suitSearch(leadCard.suit)) == 0:
        longestSuits = suits[:]
        longestSuits.remove(leadCard.suit)
        longestSuitLength = 1
        tempLongestSuits = []
        for suit in longestSuits:
          suitHand = responder.suitSearch(suit)
          if len(suitHand) > longestSuitLength:
            longestSuitLength = len(suitHand)
            tempLongestSuits = [suit]
          elif len(suitHand) == longestSuitLength and len(suitHand) > 0:
            tempLongestSuits.append(suit)
        if len(responder.suitSearch(leadCard.suit)) == 0:
          for suit in tempLongestSuits:
            suitResponse=responder.suitSearch(suit)
            for givenSuitCard in suitResponse:
              validResponses[i].append(givenSuitCard)
        else:
          for suit in tempLongestSuits:
            suitResponse=responder.suitSearch(suit)
            for givenSuitCard in suitResponse:
              validResponses[i].append(givenSuitCard)
    #   winningResponses=[[],[],[]]
    #   losingResponses=[[],[],[]]
    #   for i in range(0,3):
    #     for play in validResponses[i]:
    #       canBeat=betterCard(play,leadCard,currentTrump)
    #       if canBeat:
    #         winningResponses[i].append(play)
    #       if not canBeat:
    #         losingResponses[i].append(play)
    #     if len(losingResponses[i])==0:
    #       losingResponses[i]=winningResponses[i]
    #     highestCards = {}
    #     for card in losingResponses[i]:
    #       if card.suit not in highestCards or card.numericalValue < highestCards[card.suit].numericalValue:
    #         highestCards[card.suit] = card
    #     losingResponses[i]=highestCards.values()
    # trueResponses=[[],[],[]]

    # for i in range(0,3):
    #   bettor= ( (i+1)==parentNode.bettor )
    #   if winState==1:
    #     if len(winningResponses[0])==0:
    #       trueResponses[i]=losingResponses[i]
    #     else:
    #       trueResponses[i]=winningResponses[i]
    #       winState=-1
    #   elif winState==0:
    #     if len(winningResponses[i])==0:
    #       trueResponses[i]=losingResponses[i]
    #       if bettor:
    #         winState=-1
    #     else:
    #       trueResponses[i]=winningResponses[i]
    #       if bettor:
    #         winState=1
    #   elif winState==-1:
    #     trueResponses[i]=losingResponses[i]
    trueResponses=validResponses
    for resp1 in trueResponses[0]:
      for resp2 in trueResponses[1]:
        for resp3 in trueResponses[2]:
          print(leadCard,resp1,resp2,resp3)
          allCombinations.append([leadCard,resp1,resp2,resp3])

  winners=[]
  bettorSafeTricks=[]
  for trick in allCombinations:
    trickWinner=winnerCalc(trick,currentTrump,leadCard.suit,True)
    if trickWinner!=0:
      bettorSafeTricks.append(trick)
      winners.append(trickWinner)


  allChildren=combo2Nodes(bettorSafeTricks,winners, parentNode.depth, parentNode.playOrder, parentNode.played)
  nodeMakerCache[cacheKey] = allChildren

  return allChildren

"""# Random Play Nonsense"""

def longestSuit(suitDistribution,selection):
  maxSuit="♠"
  for suit in suitDistribution:
    if suitDistribution[suit]==suitDistribution[maxSuit]:
      maxSuit=compareSuits(maxSuit,suit,selection)
    elif suitDistribution[suit]>suitDistribution[maxSuit]:
      maxSuit=suit
  return maxSuit

#["♦","♣","♥","♠"]
def firstplay(selection):
  suitDistribution=suitsDistribution(selection)
  maxSuit=longestSuit(suitDistribution,selection)
  playing=None
  for card in selection:
    if card.suit==maxSuit:
      if playing is None:
        playing=card
      elif card>playing:
        playing=card
  return playing

def worstCard(hand,trump):
  if len(hand)==1:
    return hand[0]
  worstCard=hand[0]
  trumplessHand=[]
  suitDistribution=suitsDistribution(hand)
  if len(suitDistribution)==1:
    for card in hand:
      if card<worstCard:
        worstCard=card
    return worstCard
  for card in hand:
    print(card)
    if card.suit!=trump:
      print("not a trump so added")
      trumplessHand.append(card)
  print("Number of non trumps is:",len(trumplessHand))
  if len(trumplessHand)==1:
      return trumplessHand[0]
  maxSuit=longestSuit(suitDistribution,trumplessHand)
  print("Longest suit is ",maxSuit)
  print(trumplessHand)
  longSuit=[]
  for card in trumplessHand:
    print(card.suit,maxSuit)
    if card.suit==maxSuit:
      longSuit.append(card)
  worstCard=longSuit[0]
  print(longSuit)
  print(worstCard)
  for card in longSuit:
    if card<worstCard:
      worstCard=card
      print("New worst card:",worstCard)
  return worstCard

def bestCard(hand,trump,leadSuit=None,winningCard=None,state=0):
  if len(hand)==1:
    return hand[0]
  if not winningCard:
    bestCard=hand[0]
    for card in hand:
      if card>bestCard:
        bestCard=card
      if card==bestCard:
        if card.suit==trump:
          bestCard=card
    return bestCard
  suitDistribution=suitsDistribution(hand)
  winningPlays=[]
  for card in hand:
    winner=winnerCalc([winningCard,card],trump,leadSuit)
    if winner==card:
      winningPlays.append(card)
  if len(winningPlays)==0:
    return worstCard(hand,trump)
  elif state==0:
    play=winningPlays[0]
    for card in winningPlays:
      if card>play:
        play=card
    return play
  elif state==1:
    play=winningPlays[0]
    for card in winningPlays:
      if card<play:
        play=card
    return play

  else:
     return worstCard(hand,trump)

pTest=Player("Test Player",deck[25:30])
print(pTest)
firstplay(pTest.hand)
print(pTest.heart)
testDistro=suitsDistribution(pTest.hand)
print(testDistro)
print(len(testDistro))

#state 0 means bettor hasn't played yet, 1 means bettor winning, -1 bettor losing
def play(selection,trump,state,bettor,winningCard=None,leadSuit=None):
  if len(selection)==1:
    return selection[0]
  if trump is None:
    return firstplay(selection)
  if bettor:
    if winningCard is None:
      return firstplay(selection)
    else:
      bestCard(selection,trump,leadSuit,winningCard,state)
  if state==1 or state==0:
    return bestCard(selection,trump,leadSuit,winningCard,state)
  if state==-1:
    return worstCard(selection,trump)

#Figure out what you wanna return specifically, how to return index of winnning player
#state 0 means bettor hasn't played yet, 1 means bettor winning, -1 bettor losing
def round(players,leadIndex,bettor,trump=None):
  print("\n")
  print("Round started, trump is ",trump)
  order=players[leadIndex:]+players[:leadIndex]
  state=0
  print("ORDER: ",end="")
  for person in order:
    print(person.name,end=" ")
  print("\n")
  playedCard=[0]
  winner=order[0]
  print(order[0]," leads:",end=" ")
  bettorPlay= bettor==order[0]
  if bettorPlay:
    state=1
  playedCard[0]=play(order[0].hand,trump,0,bettorPlay)
  print(playedCard[0])
  winningCard=playedCard[0]
  order[0].removeCard(playedCard[0])
  suitFollowing=playedCard[0].suit
  bettorPlayed=bettorPlay
  if trump is None:
    trump=playedCard[0].suit
  for i in range(1,len(order)):
    bettorPlay= bettor==order[i]
    print(order[i],":",end=" ")
    playchoice=[]
    for card in order[i].hand:
      if card.suit==suitFollowing:
        playchoice.append(card)
    if len(playchoice)==0:
      playedCard.append(play(order[i].hand,trump,state,bettorPlay,winningCard,suitFollowing))
      order[i].removeCard(playedCard[i])
    else:
      playedCard.append(play(playchoice,trump,state,bettorPlay,winningCard,suitFollowing))
      order[i].removeCard(playedCard[i])
    print(playedCard[i])
    if bettorPlay:
      bettorPlayed=True
    newWinner=winnerCalc(playedCard,trump,suitFollowing)
    if newWinner!=winningCard:
      winningCard=newWinner
      winner=order[i]
      if bettorPlayed:
        if winner==bettor:
          state=1
        else:
          state=-1
  print("Winner is ",winner.name," playing ",winningCard)
  return (winner,trump,playedCard)

def removeCards(playedCards,players):
  for card in playedCards:
    for player in players:
      if card in player.hand:
        player.hand.remove(card)
        break
  return players

#Figure out how to run multiple rounds
def misere(players,betGoal,bettor):
  lead=0
  successfulTricks=0
  trump=None
  playedCards=[]
  for i in range(5):
    lead,trump,playedCards=round(players,lead,bettor,trump)
    lead=players.index(lead)

    if lead==0:
      successfulTricks+=1
    if successfulTricks==betGoal:
      print("Bettor wins")
      i=4

activeplayers=[p1,p2,p3]
misere(activeplayers,2,p1)

counting=[0,1,2,3,4,5,6]
wrapped=counting[2:]
wrapped+=counting[:2]
print(wrapped)
print(len(activeplayers))
print(activeplayers[0])
testlist=["test"]
print(testlist[-1])

"""# Winning Queue

"""

from collections import deque

# Assume Node and treePlayerOrder are defined in previous successful cells.
# Create the root node for the BFS traversal.
# Assuming the root node represents the initial state before any tricks are played.
# The parameters should match the Node class constructor: children, playOrder, played, depth, bettor.
# Based on the Node definition in cell eh8Xshq7Ri_W (which had bettor=0), and htiCYKxSDiJ8 (which had bettor=playOrder[0] and then default 0),
# let's use the version from eh8Xshq7Ri_W with bettor=0 as it was successfully executed.
# If your Node definition has changed, you may need to adjust these parameters.
rootNode = Node([], treePlayerOrder, [], 0, 0) # Assuming Node(children, playOrder, played, depth, bettor)

# Create a deque object to use as a queue for BFS
queue = deque()

# Add the root node to the queue
queue.append(rootNode)

# Display the queue to confirm the root node was added
print("Queue initialized:")
print(queue)
print(f"Queue size: {len(queue)}")

while queue:
    currentLevelSize = len(queue)
    nextLevelNodes = []
    for _ in range(currentLevelSize):
        currentNode = queue.popleft()
        children = nodeMaker(currentNode)
        if children:
            currentNode.children.extend(children)
            nextLevelNodes.extend(children)
    nodeMakerCache.clear()
    queue.extend(nextLevelNodes)

from collections import deque

def analyzeGameTree(rootNode):
    """
    Analyzes the game tree to calculate the average number of tricks won for each starting play
    and the total number of completed game states (depth 5 nodes).

    Args:
        rootNode: The root node of the game tree.

    Returns:
        A tuple containing:
        - A dictionary where keys are the starting cards (as Card objects) and values
          are the average number of tricks won by the bettor when that card is the first card played.
        - An integer representing the total number of completed game states (depth 5 nodes).
        Returns (None, 0) if all average tricks won by the bettor are 0 for all starting plays
        and there are no completed game states, indicating a potential error.
    """
    startingPlayResults = {}
    totalGameStates = 0

    # The children of the root node represent the possible first plays.
    for firstTrickNode in rootNode.children:
        # The first card played in this trick is the starting play
        startingCard = firstTrickNode.played[0]

        totalTricksWonByBettor = 0
        numGameEndings = 0

        # Use a deque for BFS to traverse the subtree starting from firstTrickNode
        queue = deque([firstTrickNode])

        while queue:
            currentNode = queue.popleft()

            if currentNode.depth == 5:
                # This is a leaf node representing a completed game
                totalGameStates += 1 # Count this completed game state
                numGameEndings += 1 # Count this as a game ending for the current starting play

                # The played list in a depth 5 node contains all 5 tricks (20 cards)
                allPlayedCards = currentNode.played
                print(allPlayedCards)

                # Calculate the tricks won by the original bettor (index 0) in this game ending.
                # Use the fullGameScorer function.
                # Assuming fullGameScorer can process the 'played' list from the depth 5 node.
                scores = fullGameScorer(allPlayedCards) # Use the existing fullGameScorer

                # The original bettor is at index 0 in treePlayerOrder
                gameTricksWonByBettor = scores[0]

                totalTricksWonByBettor += gameTricksWonByBettor


            elif currentNode.children:
                # Add children to the queue for further exploration
                queue.extend(currentNode.children)

        if numGameEndings > 0:
            averageTricks = totalTricksWonByBettor / numGameEndings
            startingPlayResults[startingCard] = averageTricks
        else:
            # This case should theoretically not be reached if the tree is fully explored
            startingPlayResults[startingCard] = 0

    # Check if all average tricks won for the bettor are 0 and no game states were found
    allBettorTricksAreZero = all(value == 0 for value in startingPlayResults.values())

    if allBettorTricksAreZero and totalGameStates == 0:
         print("Warning: No completed game states (depth 5 nodes) found in the tree.")
         return (None, 0)
    elif allBettorTricksAreZero and len(startingPlayResults) > 0:
        print("Warning: For all starting plays, the bettor's average tricks won is 0. This might indicate an issue with the tree exploration, scoring, or game rules.")
        # Returning the results with the warning.


    return (startingPlayResults, totalGameStates)

# Assuming the root node created in cell e7843438 is accessible as 'root_node'
# and the treePlayerOrder is accessible as 'treePlayerOrder'
# You can call the function like this after the tree is built:
# game_analysis_results, total_states = analyzeGameTree(root_node)
# print("Average tricks won per starting play:", game_analysis_results)
# print("Total completed game states:", total_states)

# Note: The code assumes treePlayerOrder is a global variable or accessible
# in the scope where analyzeGameTree is called and where fullGameScorer is defined/called.
# If not, you might need to pass it as an argument.

gameAnalysisResults, totalGameStates = analyzeGameTree(rootNode)

if gameAnalysisResults is not None:
    print("Average tricks won by the bettor per starting play:")
    # Sort the results by average tricks won for better readability
    sortedResults = sorted(gameAnalysisResults.items(), key=lambda item: item[1], reverse=True)
    for card, averageTricks in sortedResults:
        print(f"  Starting with {card}: {averageTricks:.2f} tricks")

print(f"\nTotal completed game states (depth 5 nodes): {totalGameStates}")

"""# Losing Queue"""

from collections import deque

# Assume Node and treePlayerOrder are defined in previous successful cells.
# Create the root node for the BFS traversal.
# Assuming the root node represents the initial state before any tricks are played.
# The parameters should match the Node class constructor: children, playOrder, played, depth, bettor.
# Based on the Node definition in cell eh8Xshq7Ri_W (which had bettor=0), and htiCYKxSDiJ8 (which had bettor=playOrder[0] and then default 0),
# let's use the version from eh8Xshq7Ri_W with bettor=0 as it was successfully executed.
# If your Node definition has changed, you may need to adjust these parameters.
rootMisereNode = Node([], treePlayerOrder, [], 0, 0) # Assuming Node(children, playOrder, played, depth, bettor)

# Create a deque object to use as a queue for BFS
queue = deque()

# Add the root node to the queue
queue.append(rootMisereNode)

# Display the queue to confirm the root node was added
print("Queue initialized:")
print(queue)
print(f"Queue size: {len(queue)}")

while queue:
    currentLevelSize = len(queue)
    nextLevelNodes = []
    for _ in range(currentLevelSize):
        currentNode = queue.popleft()
        children = nodeMakerMisere(currentNode)
        if children:
            currentNode.children.extend(children)
            nextLevelNodes.extend(children)
    nodeMakerCache.clear()
    queue.extend(nextLevelNodes)

from collections import deque

def analyzeMisereGameTree(rootNode, bettor_hand):
    """
    Analyzes the misere game tree based on the first card played by the bettor.

    For each starting card, it calculates:
    - The average depth of all leaf nodes in the subtrees initiated by that card.
    - The number of completed game states (depth 5 nodes) where the bettor wins zero tricks
      in the subtrees initiated by that card.

    Args:
        rootNode: The root node of the misere game tree. Its children represent
                  the outcomes of the first trick where the bettor did NOT win the trick.
        bettor_hand: The list or tuple of Card objects in the bettor's original hand.

    Returns:
        A dictionary where keys are the starting cards (as Card objects).
        Each value is another dictionary containing:
        - 'average_leaf_depth': The average depth of all leaf nodes in the subtrees
                                originating from this starting card.
        - 'zero_trick_depth5_count': The total count of depth 5 leaf nodes across all
                                     subtrees for this starting card where the bettor won zero tricks.
        - 'total_depth5_count': The total count of depth 5 nodes across all subtrees
                                for this starting card.
    """
    startingPlayAnalysis = {}
    root_children_starting_cards = {child.played[0] for child in rootNode.children}

    # First, process the starting cards for which subtrees were explored (present in root.children)
    for firstTrickNode in rootNode.children:
        startingCard = firstTrickNode.played[0]

        # Initialize analysis data for this starting card if not already present
        if startingCard not in startingPlayAnalysis:
             startingPlayAnalysis[startingCard] = {
                'total_leaf_nodes': 0,
                'sum_of_leaf_depths': 0,
                'zero_trick_depth5_count': 0, # Initialize for each starting card
                'total_depth5_count': 0
            }
        # Ensure zeroTrickDepth5Count and totalDepth5Count are initialized for the current startingCard entry
        # This is necessary if a starting card appears in multiple root children (different first trick outcomes)
        # but we want to aggregate results per starting card.
        # Let's re-structure slightly to aggregate after the loop for clarity and correctness.
        # For now, initialize local counters for the current subtree traversal.
        current_subtree_zero_tricks_depth5 = 0
        current_subtree_total_depth5 = 0
        current_subtree_total_leaf_nodes = 0
        current_subtree_sum_of_leaf_depths = 0


        # Use a deque for BFS to traverse the subtree starting from firstTrickNode
        queue = deque([firstTrickNode])

        while queue:
            currentNode = queue.popleft()

            if currentNode.depth == 5:
                current_subtree_total_depth5 += 1
                # Check if the bettor won zero tricks in this completed game state
                # Assuming the bettor is always player at index 0 in the original playOrder
                # and fullGameScorer correctly scores based on the full 20 cards.
                # The 'played' list in the depth 5 node contains all 20 cards.
                scores = fullGameScorer(currentNode.played)
                if scores[0] == 0: # Assuming bettor is player 0
                    current_subtree_zero_tricks_depth5 += 1


            # Check if the node is a leaf node (has no children)
            if not currentNode.children:
                current_subtree_total_leaf_nodes += 1
                current_subtree_sum_of_leaf_depths += currentNode.depth


            elif currentNode.children:
                # Add children to the queue for further exploration
                queue.extend(currentNode.children)

        # Aggregate results for this starting card from this specific firstTrickNode subtree
        # Since a starting card can lead to multiple firstTrickNodes, we need to sum up results.
        # The previous initialization logic might overwrite. Let's ensure we add to existing counts.
        startingPlayAnalysis[startingCard]['total_leaf_nodes'] += current_subtree_total_leaf_nodes
        startingPlayAnalysis[startingCard]['sum_of_leaf_depths'] += current_subtree_sum_of_leaf_depths
        startingPlayAnalysis[startingCard]['zero_trick_depth5_count'] += current_subtree_zero_tricks_depth5
        startingPlayAnalysis[startingCard]['total_depth5_count'] += current_subtree_total_depth5


    # Now, add entries for starting cards from the bettor's hand that were NOT in root.children
    # These are cards that resulted in an immediate loss (winning the first trick)
    for card in bettor_hand:
        if card not in root_children_starting_cards:
            startingPlayAnalysis[card] = {
                'total_leaf_nodes': 1, # The root node itself is a leaf in this branch
                'sum_of_leaf_depths': 0, # Depth of root is 0
                'zero_trick_depth5_count': 0, # Bettor immediately loses misere
                'total_depth5_count': 0     # No depth 5 nodes reached
            }

    # Calculate average leaf depth for each starting card in the final results
    finalAnalysisResults = {}
    for startingCard, data in startingPlayAnalysis.items():
        averageLeafDepth = data['sum_of_leaf_depths'] / data['total_leaf_nodes'] if data['total_leaf_nodes'] > 0 else 0.0
        finalAnalysisResults[startingCard] = {
            'average_leaf_depth': averageLeafDepth,
            'zero_trick_depth5_count': data['zero_trick_depth5_count'],
            'total_depth5_count': data['total_depth5_count']
        }


    return finalAnalysisResults

# Analyze the rootMisereNode tree
# Get the bettor's original hand from the rootNode's playOrder using 'dealt'
bettors_original_hand = rootMisereNode.playOrder[0].dealt
misereAnalysisResults = analyzeMisereGameTree(rootMisereNode, bettors_original_hand)

if misereAnalysisResults:
    print("Misere Game Tree Analysis per Starting Play:")
    # Sort the results by average leaf depth for better indication of rounds survived
    sortedResults = sorted(misereAnalysisResults.items(), key=lambda item: item[1]['average_leaf_depth'], reverse=True)
    for card, analysis in sortedResults:
        print(f"  Starting with {card}:")
        print(f"    Average depth of all leaf nodes (rounds survived): {analysis['average_leaf_depth']:.2f}")
        print(f"    Completed games (depth 5) with zero tricks for bettor: {analysis['zero_trick_depth5_count']}")
        print(f"    Total completed games (depth 5): {analysis['total_depth5_count']}")
else:
    print("No misere game tree analysis results found. The tree might not have been built correctly or the root node has no children.")

# Re-analyze the rootMisereNode tree with the corrected tree structure
# Assuming treePlayerOrder[0].hand contains the bettor's hand
misereAnalysisResults = analyzeMisereGameTree(rootMisereNode, treePlayerOrder[0].hand)

if misereAnalysisResults:
    print("Misere Game Tree Analysis per Starting Play (Updated):")
    # Sort the results by average leaf depth for better indication of rounds survived
    sortedResults = sorted(misereAnalysisResults.items(), key=lambda item: item[1]['average_leaf_depth'], reverse=True)
    for card, analysis in sortedResults:
        print(f"  Starting with {card}:")
        print(f"    Average depth of all leaf nodes (rounds survived): {analysis['average_leaf_depth']:.2f}")
        print(f"    Completed games (depth 5) with zero tricks for bettor: {analysis['zero_trick_depth5_count']}")
        print(f"    Total completed games (depth 5): {analysis['total_depth5_count']}")
else:
    print("No misere game tree analysis results found. The tree might not have been built correctly or the root node has no children.")

print(len(rootMisereNode.children))
for child in rootMisereNode.children:
  print(child.played[0])
print(treePlayerOrder[0].hand)

from collections import deque

def calculate_bettor_tricks_at_node(played_cards_in_path, trump_suit, original_play_order, bettor_player_index=0):
    """
    Calculates the number of tricks won by the bettor based on the sequence of played cards in a path.

    Args:
        played_cards_in_path: A list of Card objects representing the sequence of cards played along a path to a node.
                              This list includes cards played by all players in trick order.
        trump_suit: The trump suit for the game.
        original_play_order: The list of Player objects in their original order.
        bettor_player_index: The index of the bettor in the original playOrder.

    Returns:
        The number of tricks won by the bettor based on the provided sequence of played cards.
    """
    if not played_cards_in_path:
        return 0

    trick_scores = [0] * len(original_play_order)
    cards_per_trick = len(original_play_order) # Should be 4
    num_tricks_in_path = len(played_cards_in_path) // cards_per_trick

    current_leader_original_index = 0 # The bettor is always the leader of the first trick in the explored misere subtrees (children of root)

    for i in range(num_tricks_in_path):
        trick_start_index = i * cards_per_trick
        trick_end_index = trick_start_index + cards_per_trick
        current_trick_cards = played_cards_in_path[trick_start_index:trick_end_index]

        if len(current_trick_cards) != cards_per_trick:
             # This can happen if played_cards_in_path doesn't end on a trick boundary
             # For full node paths, this should be fine.
             break # Or handle as an error/warning

        # Determine the winner of the current trick based on the cards played and trump
        winner_relative_index = roundWinner(current_trick_cards, trump_suit)

        # Map the relative winner index to the original player index
        # The players in this trick are in the order: leader, leader+1, leader+2, leader+3 (mod 4)
        trick_play_order_original_indices = [(current_leader_original_index + j) % len(original_play_order) for j in range(cards_per_trick)]
        original_winner_index = trick_play_order_original_indices[winner_relative_index]

        trick_scores[original_winner_index] += 1

        # The winner of this trick leads the next round
        current_leader_original_index = original_winner_index

    return trick_scores[bettor_player_index]


def extract_viz_data_with_bettor_plays(node, trump_suit, original_play_order, bettor_player_index=0, current_path_bettor_plays=None):
    """
    Recursively extracts data for visualization, tracking the bettor's played cards along the path.

    Args:
        node: The current Node in the tree.
        trump_suit: The trump suit for the game.
        original_play_order: The list of Player objects in their original order.
        bettor_player_index: The index of the bettor in the original playOrder.
        current_path_bettor_plays: A list of cards played by the bettor to reach this node.
                                   Defaults to None for the root.

    Returns:
        A dictionary containing data for the current node and its subtree,
        including number of leaves, bettor's trick count status, and the bettor's played cards in this path.
    """
    if current_path_bettor_plays is None:
        current_path_bettor_plays = []

    # Determine the card played by the bettor to reach this node (if not root)
    # This requires knowing the play order for the trick that led to this node.
    # For children of the root (depth 1), the bettor (player 0) played the first card in node.played.
    # For nodes at depth > 1, the bettor's card is the card played by the bettor
    # in the last trick of the parent node's played list.
    # We need to figure out the bettor's position in that last trick's played cards.

    # This is still tricky without modifying the Node structure.
    # Let's simplify and just track the full path played cards in the recursive call,
    # and calculate bettor tricks from that within calculate_bettor_tricks_at_node.

    # Let's refine the recursive function to pass the full sequence of played cards to the children.
    # The played cards in a child node are the parent's played cards + the cards played in the trick leading to the child.

    # Let's try a simpler recursive structure that focuses on the node's played list and depth.

    node_data = {
        'depth': node.depth,
        'played_card_in_trick': node.played[-1] if node.depth > 0 else None, # The last card played in the trick leading to this node
        'is_leaf': not node.children,
        'num_leaves_in_subtree': 0, # Will be calculated after processing children
        'bettor_tricks_won': calculate_bettor_tricks_at_node(list(node.played), trump_suit, original_play_order, bettor_player_index),
        'children': []
    }

    if node.children:
        total_leaves_in_children = 0
        for child in node.children:
            # Pass the child node's played list (which includes parent's played + new trick)
            child_data = extract_viz_data_with_bettor_plays(child, trump_suit, original_play_order, bettor_player_index)
            node_data['children'].append(child_data)
            total_leaves_in_children += child_data['num_leaves_in_subtree']
        node_data['num_leaves_in_subtree'] = total_leaves_in_children
    else:
        node_data['num_leaves_in_subtree'] = 1 # A leaf node has 1 leaf (itself)


    return node_data

# Assuming rootMisereNode and treePlayerOrder are defined
# The trump suit is determined by the first card played in the first trick (children of root)
# Assuming the first child exists and its first played card determines the trump
# If rootMisereNode has no children, we might need to handle this case.
if rootMisereNode and rootMisereNode.children:
  # Find the trump suit from one of the first trick outcomes (children of root)
  # The trump suit is the suit of the card led by the bettor in the first trick.
  # The bettor is player 0 in the original play order.
  # The children of the root represent the first trick outcomes where the bettor led.
  # So, the first card in any child's played list is the card the bettor led in that specific first trick outcome.
  trump_suit_for_viz = None
  for child in rootMisereNode.children:
      if child.played and len(child.played) >= 4: # Ensure it's a complete trick
          # The first card in the child's played list is the bettor's lead card for that trick
          # We need to confirm this is always the case based on nodeMakerMisere.
          # Assuming nodeMakerMisere puts the leader's card first in the child's played list for the first trick.
          trump_suit_for_viz = child.played[0].suit
          break # Assuming trump is consistent across all first trick outcomes

  if trump_suit_for_viz is None:
      print("Could not determine trump suit from root's children.")
      game_tree_data = None # Cannot proceed with visualization data extraction

  else:
      # Now extract data, starting from the root
      # The root itself doesn't have a played card or trick score yet
      # The bettor's trick count is 0 at the root.
      # We need to handle the initial state for the visualization.

      # Let's create a structure for the root's data.
      root_viz_data = {
          'depth': 0,
          'played_card_in_trick': None,
          'is_leaf': not rootMisereNode.children,
          'num_leaves_in_subtree': 0, # Calculate based on children
          'bettor_tricks_won': 0,
          'children': []
      }

      total_leaves_from_root_children = 0
      for child in rootMisereNode.children:
           # For children of the root (depth 1), their played list contains the cards of the first trick.
           child_data = extract_viz_data_with_bettor_plays(child, trump_suit_for_viz, treePlayerOrder, bettor_player_index=0)
           root_viz_data['children'].append(child_data)
           total_leaves_from_root_children += child_data['num_leaves_in_subtree']

      root_viz_data['num_leaves_in_subtree'] = total_leaves_from_root_children if rootMisereNode.children else 1 # If root has no children, it's a leaf

      game_tree_data = root_viz_data

      # Now 'game_tree_data' contains the structured data for visualization
      # You can process this dictionary to build the Icicle Chart

      # Example: Print some of the extracted data structure
      print("Extracted Visualization Data (sample):")
      # Print data for the root and its immediate children
      print(f"Root Node: Depth={game_tree_data['depth']}, Is Leaf={game_tree_data['is_leaf']}, Leaves in Subtree={game_tree_data['num_leaves_in_subtree']}, Bettor Tricks={game_tree_data['bettor_tricks_won']}")
      print("Root Children Data (sample):")
      for i, child_data in enumerate(game_tree_data['children'][:5]): # Print data for first 5 children
          print(f"  Child {i+1}: Depth={child_data['depth']}, Played Card in Trick={child_data['played_card_in_trick']}, Is Leaf={child_data['is_leaf']}, Leaves in Subtree={child_data['num_leaves_in_subtree']}, Bettor Tricks={child_data['bettor_tricks_won']}")

else:
    print("Root node or its children not available for visualization data extraction.")

"""# Icicle Chart

After that function to ge
"""